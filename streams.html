<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" media="all" href="bower_components/sass-bootstrap/dist/css/bootstrap.min.css">
  <link rel="stylesheet" media="all" href="bower_components/sass-bootstrap/dist/css/bootstrap-theme.min.css">
  <link rel="stylesheet" media="all" href="streams.css">
  <title>Streams in JavaScript</title>
</head>
<body>
  <div class="container">
    <div class="page-header">
      <h1>
        Sequences On A Computer
      </h1>
    </div>

    <section>
      <h2>
        Big Picture
      </h2>

      <p>
        We can think of the natural numbers as a list containing two elements:
      </p>
      <ul>
        <li>the number 1, and</li>
        <li>a list containing two elements:</li>
          <ul>
            <li>the sum of 1 and that first element (which was 1), and</li>
            <li>a list containing two elements:</li>
              <ul>
                <li>the sum of 1 and <em>that</em> first element (which was 1 + 1 = 2), and</li>
                <li>a list containing two elements: ...</li>
              </ul>
          </ul>
      </ul>
      <p>
        Since we can see the repeating pattern and we understand "..." to mean "continue this pattern indefinitely," we can express the infinite set of natural numbers in the finite space above (assuming we already have the number 1 and addition). Could we make a computer "think" similarly in order to express the natural numbers in a computer's finite memory? Or, could we do the next best thing and make the computer give us any natural number on demand, thus presenting the illusion of having all the natural numbers in memory?
      </p>
    </section>



    <section>
      <h2>
        Plan
      </h2>

      <ol>
        <li><a href="#this-page">Notes about this page</a></li>
        <li><a href="#build-stream">Build a list-like data structure called a stream.</a></li>
        <li><a href="#build-sequence">Build sequences, using streams.</a></li>
        <li><a href="#use">Usefulness</a></li>
        <li><a href="#application">Application: numerical integral approximator</a></li>
      </ol>
    </section>



    <section>
      <a name="this-page"></a>

      <h2>
        Notes about this page
      </h2>

      <p>
      All of the functions defined on this page are already available for you to use in the JavaScript console of this browser window/tab. If you want to run the examples, you can do so by copying and pasting them from the code listing on the page into the JavaScript console and hit enter:
      </p>
      
      <ul class="text-muted">
        <li>
          Bring up the JavaScript console:
          <ul>
            <li>
              Chrome: control + shift + j (Mac: alt + command + j)
            </li>
            <li>
              Firefox: control + shift + k (Mac: alt + command + k)
            </li>
            <li>
              Safari: maybe control + shift + c (Mac: alt + command + c)
            </li>
            <li>
              Internet Explorer: should be F12, then you may need to click a "console" botton across the top of the panel that comes up
            </li>
          </ul>
        </li>
        <li>
          Enter runs a piece of code you've typed into the prompt at the console.
        </li>
        <li>
          Shift + enter goes to a new line without running the code you're typing.
        </li>
      </ul>

      <p>
        I want to like Firefox but I would use Chrome of the two: in running the code below to find the second prime between 10,000 and 100,000, Chrome was 100X faster than Firefox. (And Chrome was 1,000X faster than Opera.) Additionally, I ran the benchmarks below for 100,000 iterations in Chrome; Firefox would do 10,000 but "broke" on 100,000. (Opera did manage the 100,000-iteration run but was very slow, as before.)
      </p>

      <p>
      To avoid getting into the JavaScript language, we'll use a library called <a href="http://underscorejs.org/">Underscore.js</a> that provides functions for building, transversing, selecting, and transforming collections and objects. Functions that look like _.<em>functionName</em> (i.e., a succession of underscore, period, and function name) come from this library.
      </p>
    </section>



    <section>
      <a name="build-stream"></a>

      <h2>
        Build Streams
      </h2>

      <section>
        <h3>
          Start with lists
        </h3>

        <p>
          From SICP, first edition, p242: "From an abstract point of view, a stream is simply a sequence of data objects."
        </p>
        
        <p>
          A list is such a sequence so let's start there. We need, 1) a function to make a list, and 2) functions to access elements of the list. For reasons that will become clear below, let's implement a list as a pair of items. <span class="new-code-ref">cons</span> (as in "construct") will make the list, <span class="new-code-ref">first</span> will select the first element, and <span class="new-code-ref">rest</span> will select the sublist of all the elements after the first element. Since Underscore already defines these functions, we can cheat and use theirs.
        </p>

        <div class="code-listing">
          <span class="listing-heading">cons</span>
          <span class="listing-secondary-heading">item, list &#8614; list containing the first item and then all the items of the list given as the second argument</span>
          <pre>var cons = _.cons;</pre>
        </div>

        <p>
        More enlighteningly, we can define <span class="code">cons</span> ourselves to wrap the given item in a list and concatenate it with the given list:
        </p>

        <div class="code-listing">
          <span class="listing-heading">ourCons</span>
          <span class="listing-secondary-heading">item, list &#8614; list containing the first item followed by the items of the list given as the second argument</span>
      <pre>var ourCons = function (first, rest) {
        return [first].concat(rest);
      };</pre>
          <p class="text-muted">
          NOTE: While we could define <span class="code">cons</span> and the following functions purely in terms of functions, we can reach our goal of sequences more quickly by implementing lists in terms of JavaScript's list-like form, Array.
          </p>
          <p class="text-muted">
            <span class="code">[]</span> creates a new, empty array
          </p>
          <p class="text-muted">
          <span class="code">["dog", "great dog"]</span> creates an array containing <span class="code">"dog"</span> and <span class="code">"great dog"</span>.
          </p>
          <p class="text-muted">
            JavaScript also provides the <span class="code">concat</span> method for arrays: <span class="code">["dog", "great dog"].concat(["Spook dog"])</span> creates the new array <span class="code">["dog", "great dog", "Spook dog"]</span>.
          </p>
        </div>

        <p>
        With this implementation of <span class="code">ourCons</span>, we need a base case for lists so we have something onto which to concatenate elements in the first place. Let's use an empty array:
        </p>

        <div class="code-listing">
          <span class="listing-heading">theEmptyList</span>
          <pre>var theEmptyList = [];</pre>
        </div>

        <p>
          Since the goal is to build sequences and not to examine the JavaScript language, I'll use Underscore's functions where possible from here on out.
        </p>
        
        <div class="code-listing">
          <span class="listing-heading">first</span>
          <span class="listing-secondary-heading">list &#8614; first item of the list</span>
          <pre>var first = _.first;</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">rest</span>
          <span class="listing-secondary-heading">list &#8614; sublist starting with the second item of the given list</span>
          <pre>var rest = _.rest;</pre>
        </div>

        <div class="example">
          <pre>var spookDogList = ourCons("Spook", theEmptyList);</pre>
          <span class="code return-value"><span class="return-value-prefix">effect:</span>spookDogList is ["Spook"]</span>

          <pre>var grayDogList = ourCons("Rick", spookDogList);</pre>
          <span class="code return-value"><span class="return-value-prefix">effect:</span>grayDogList is ["Rick", "Spook"]</span>

          <pre>var dogList = cons("J and Kelli's dog", grayDogList);</pre>
          <span class="code return-value"><span class="return-value-prefix">effect:</span>dogList is ["J and Kelli's dog", "Rick", "Spook"]</span>

          <pre>first(dogList);</pre>
          <span class="code return-value"><span class="return-value-prefix">yields:</span>"J and Kelli's dog"</span>

          <pre>rest(dogList);</pre>
          <span class="code return-value"><span class="return-value-prefix">yields:</span>["Rick", "Spook"]</span>
        </div>
      </section>



      <section>
        <h3>
          From lists to streams
        </h3>

        <p>
          As we see above, when a list is created its elements all exist in the computer's memory (by default in most languages, including JavaScript). A computer has finite memory so we can't build a sequence as a simple list. Let's therefore define a <strong>stream</strong> to differ from a list in that the elements of a stream will be created only as we ask for them.
        </p>

        <p>
          A sequence can be viewed as a first element and a sequence of the rest of the elements. Let's implement streams such that the first element of the stream is created and the rest of the stream exists as a sort of promise that its elements can be created as needed.
        </p>

        <p class="text-muted">
          NOTE: The stream we implement could be called "delayed" or some degree of "lazy" (in that the elements are not created when the stream is created). I'm following SICP in <em>not</em> calling this implementation a "lazy stream" because streams can be implemented to be much lazier. (And indeed they are, later in SICP.) Our stream will be plenty good enough for building sequences, though.
        </p>

        <p>
          We can delay the creation of the rest of the stream by wrapping it in a function (call it "f" for now), as we will see below. We'll then use an explicit <span class="new-code-ref">force</span> function to evaluate f, which will return the next element of the stream and a new f that delays the creation of the rest of the stream.
        </p>

        <div class="code-listing">
          <span class="listing-heading">force</span>
          <span class="listing-secondary-heading">function &#8614; result of calling the given function</span>
    <pre>var force = function (f) {
      return f();
    };</pre>
        </div>

        <p>
          Similar to lists, let the function <span class="code">consStream</span> (as in "construct stream") make a new stream. If we use a simple delay, as above, then <span class="code">consStream</span> looks just like <span class="code">cons</span>:
        </p>

        <div class="code-listing">
          <span class="listing-heading">consStream <em>(to be redefined below)</em></span>
          <span class="listing-secondary-heading">item, stream &#8614; stream</span>
          <pre>var consStream = cons;</pre>
        </div>

        <p>
          Streams are not lists, though: the tail of a stream is a <em>function</em> to compute the first element and the tail of the rest of stream and once we've computed a given tail, there is no reason to compute it again. For example, if we ask for the second element of the stream, we have to compute the tail of the stream. If we ask for the second element again, then there is no reason to repeat the computation of that tail. Also, if we have a stream representing the Fibonacci numbers and we compute the second Fibonacci number, there is no reason to compute it again when computing the third and the fourth Fibonacci numbers.
        </p>

        <p>
          Therefore, let's introduce a function <span class="new-code-ref">memoProc</span> (as in "memoize procedure") that will accept a function (call it "f") and yield another function ("g") such that:
          <ul>
            <li>
              when g is called the first time, the result of calling f (our actual function of interest) is computed and stored and returned, and
            </li>
            <li>
              when g is called subsequently, the stored result of calling f is returned (and no additional computation is done).
            </li>
          </ul>
        </p>

        <div class="code-listing">
          <span class="listing-heading">memoProc</span>
          <span class="listing-secondary-heading">function of interest &#8614; function that, when called, returns the memoized result of calling the function of interest</span>
          <pre>var memoProc = function (f) {
  var wasAlreadyRun = false,
      result;

  return function () {
    if (_.not(wasAlreadyRun)) {
      result = f();
      wasAlreadyRun = true;
    }
    return result;
  };
};</pre>
        </div>

        <p>
          With <span class="code">memoProc</span> in hand, let's redefine <span class="new-code-ref">consStream</span>:
        </p>

        <div class="code-listing">
          <span class="listing-heading">consStream</span>
          <span class="listing-secondary-heading">item, stream &#8614; stream</span>
          <pre>var consStream = function (head, tail) {
  return cons(head, memoProc(tail));
};</pre>

          <p class="text-muted">
            NOTE: Just as with mathematical notation, since <span class="code">head</span> is one of the arguments to the function (a descriptive name but it works just like an <span class="code">x</span> or a <span class="code">y</span>), when we're inside of the function body <span class="code">head</span> refers to that argument. I.e., the word <span class="code">head</span> inside the function body does not refer to the <span class="code">head</span> function defined below.
          </p>

          <p class="text-muted">
            On the other hand, <span class="code">delay</span> is not an argument of consStream and is not defined within the function so it must refer to something outside the function. (This is just like defining f(x) and then defining g(x) to refer to f(x). For example, g(x) = 1/f(x). Since f is not a paramter of g, f must refer to something outside of g.)
          </p>
        </div>
        
        <p>
          Let the function <span class="new-code-ref">head</span> map a stream to the first element of that stream. I.e., <span class="code">head</span> does the same thing as <span class="code">first</span> and can therefore be defined as an alias to <span class="code">first</span>:
        </p>

        <div class="code-listing">
          <span class="listing-heading">head</span>
          <span class="listing-secondary-heading">stream &#8614; first element of stream</span>
          <pre>var head = first;</pre>
        </div>

        <p>
          Let the function <span class="new-code-ref">tail</span> map a stream to the rest of that stream; i.e., all of the stream after the first element. <span class="code">tail</span> is similar to <span class="code">rest</span> but we also want <span class="code">tail</span> to cause the first of the rest of the elements to be created. Let's effect that creation with our <span class="code">force</span> function:
        </p>

        <div class="code-listing">
          <span class="listing-heading">tail</span>
          <span class="listing-secondary-heading">stream &#8614; substream starting at second element of stream</span>
          <pre>var tail = _.compose(force, first, rest);</pre>
          <p class="text-muted">
            Underscore provides the <span class="code">_.compose</span> function to compose functions. Let X, Y, and Z be sets and let f : X &#8594; Y, g : Y &#8594; Z. Then <span class="code">_.compose(g, f)</span> is the function g(f) : X &#8594; Z, such that x &#8614; g(f(x)).
          </p>
        </div>

        <p>
          Let's build a base-case stream as well.
        </p>

        <div class="code-listing">
          <span class="listing-heading">theEmptyStream</span>
          <pre>var theEmptyStream = [];</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">isEmptyStream</span>
          <span class="listing-secondary-heading">empty stream &#8614; true</span>
          <span class="listing-secondary-heading">non-empty stream &#8614; false</span>
          <pre>var isEmptyStream = function (stream) {
  return _.isEmpty(stream);
};</pre>
        </div>

        <p>
        Let <span class="new-code-ref">nthStream</span> select the zero-based nth element of the stream. I.e., <span class="code">nthStream(2, s)</span> is equivalent to <span class="code">head(tail(tail(s)))</span>.
        </p>

        <div class="code-listing">
          <span class="listing-heading">nthStream</span>
          <span class="listing-secondary-heading">non-negative integer, stream &#8614; zero-based nth element of the stream</span>
    <pre>var nthStream = function (n, stream) {
  if (_.isZero(n)) return head(stream);
  return nthStream(n - 1, tail(stream));
};</pre>
        </div>
      </section>
    </section>



    <section>
      <a name="build-sequence"></a>

      <h2>
        Build Sequences, Using Streams
      </h2>

      <section>
        <h3>
          Using generating functions to build the natural numbers, Fibonacci numbers, and the primes
        </h3>

        <p>
          As above, one can think of the natural numbers as a list containing two elements:
        </p>

        <ul>
          <li>the number 1, and</li>
          <li>a list containing two elements:</li>
            <ul>
              <li>the sum of 1 and that first element (which was 1), and</li>
              <li>a list containing two elements:</li>
                <ul>
                  <li>the sum of 1 and <em>that</em> first element (which was 1 + 1 = 2), and</li>
                  <li>a list containing two elements: ...</li>
                </ul>
            </ul>
        </ul>

        <p>
          Let's make a generator function that expresses the idea of making the above list of two elements (a number and a similar list).
        </p>

        <div class="code-listing">
          <span class="listing-heading">integersStartingFrom</span>
          <span class="listing-secondary-heading">integer &#8614; stream that will deliver subsequent integers</span>
          <pre>var integersStartingFrom = function (n) {
  return consStream(n,
                    function () {
                      return integersStartingFrom(n + 1);
                    });
};</pre>
          <p>
            <strong>NOTE: The second argument to <span class="code">consStream</span> is a function that, when called, produces the <em>result</em> of calling <span class="code">integersStartingFrom</span> with the <span class="code">n + 1</span> value.</strong> It is this "containing" function that becomes an argument to <span class="code">memoProc</span>.
          </p>
        </div>

        <p>
          Now we can build the natural numbers:
        </p>

        <div class="code-listing">
          <span class="listing-heading">natural numbers (from generator)</span>
          <pre>var natNumsFromGen = integersStartingFrom(1);</pre>
        </div>

        <p>
          We can similarly build the Fibonacci numbers:
        </p>

        <div class="code-listing">
          <span class="listing-heading">fibonacciGenerator</span>
          <span class="listing-secondary-heading">first fib, second fib &#8614; stream that will deliver subsequent Fibonacci numbers</span>
          <pre>var fibonacciGenerator = function (a, b) {
  return consStream(a,
                    function () {
                      return fibonacciGenerator(b, a + b);
                    });
};</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">Fibonacci numbers (from generator)</span>
          <pre>var fibsFromGen = fibonacciGenerator(0, 1);</pre>
        </div>

        <p>
          We can also build the prime numbers after we build a bit of machinery: the <span class="new-code-ref">filterStream</span> function, an <span class="new-code-ref">isDivisible</span> predicate, and an implementation of the <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a> for our generator function:
        </p>

        <div class="code-listing">
          <span class="listing-heading">filterStream</span>
          <span class="listing-secondary-heading">predicate, stream &#8614; substream of elements that satisfy the predicate</span>
          <pre>var filterStream = function (predicate, stream) {
  if (isEmptyStream(stream)) return theEmptyStream;
  if (predicate(head(stream))) return consStream(head(stream),
                                                 function () {
                                                   return filterStream(predicate, tail(stream));
                                                 });
  return filterStream(predicate, tail(stream));
};</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">isDivisible</span>
          <span class="listing-secondary-heading">number, divisor &#8614; true, when number mod(divisor) = [0]</span>
          <span class="listing-secondary-heading">number, divisor &#8614; false, when number mod(divisor) &ne; [0]</span>
          <pre>var isDivisible = function (number, divisor) {
  return _.isZero(_.mod(number, divisor));
};</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">sieve</span>
          <span class="listing-secondary-heading">stream &#8614; substream of prime elements</span>
          <pre>var sieve = function (stream) {
  return consStream(head(stream),
                    function () {
                      return sieve(filterStream(function (x) {
                                                  return _.not(isDivisible(x, head(stream)));
                                                },
                                                tail(stream)));
                    });
};</pre>
        </div>

        <p>
          Having built that machinery and our generating function, we can define the <span class="new-code-ref">primes</span>:
        </p>

        <div class="code-listing">
          <span class="listing-heading">primes (from generator)</span>
          <pre>var primesFromGen = sieve(integersStartingFrom(2));</pre>
        </div>
      </section>



      <section>
        <h3>
          Using only streams to build the natural numbers, Fibonacci numbers, and the primes
        </h3>

        <p>
          Do we need generating functions? Can we define sequences entirely in terms of streams?
        </p>

        <p>
          Let <span class="new-code-ref">ones</span> be an infinite stream of 1s.
        </p>

        <div class="code-listing">
          <span class="listing-heading">ones</span>
          <pre>var ones = (function () {
  return consStream(1,
                    function () {
                      return ones;
                    });
}());</pre>
          <p>
            <strong>NOTE: <span class="code">ones</span> is the <em>result</em> of evaluating the function on the right-hand side of the equals sign</strong> (denoted by the pair of parentheses, <span class="code">()</span> , after the closing bracket of the function, <span class="code">}</span> ; <span class="code">ones</span> is <em>not</em> the function itself.
          </p>
        </div>

        <p>
          Let <span class="new-code-ref">addStreams</span> take the element-wise sum of two streams.
        </p>

        <div class="code-listing">
          <span class="listing-heading">addStreams</span>
          <span class="listing-secondary-heading">first stream, second stream &#8614; stream that is the element-wise sum of the two given streams</span>
          <span class="listing-secondary-heading">(x_n), (y_n) &#8614; (x_n + y_n)</span>
          <pre>var addStreams = function (s1, s2) {
  if (isEmptyStream(s1)) return s2;
  if (isEmptyStream(s2)) return s1;
  return consStream(head(s1) + head(s2),
                    function () {
                      return addStreams(tail(s1), tail(s2));
                    });
};</pre>
        </div>

        <p>
          Now we can build the natural numbers in terms of streams, without a generating function:
        </p>

        <div class="code-listing">
          <span class="listing-heading">natural numbers (without generator)</span>
          <pre>var natNums = (function () {
  return consStream(1,
                    function () {
                      return addStreams(ones, natNums);
                    });
}());</pre>
        </div>

        <p>
          And we can build the Fibonacci numbers similarly:
        </p>

        <div class="code-listing">
          <span class="listing-heading">Fibonacci numbers (without generator)</span>
          <pre>var fibs = (function () {
  return consStream(0,
                    function () {
                      return consStream(1,
                                        function () {
                                          return addStreams(tail(fibs), fibs);
                                        });
                    });
}());</pre>
        </div>

        <p>
          Since we aren't using generators, <span class="code">sieve</span> won't give us the primes. Therefore, we'll have to introduce one more piece of machinery to build the primes, the predicate <span class="new-code-ref">isPrime</span>. Let's use the fact that any divisor of a number n that is greater than the square root of n must have a companion divisor less than the square root of n. That is, if n = ab, then either a and b are equal to the square root of n or one of a and b are less than the square root of n and the other of and b are greater than the square root of n. (For a suitable set containing n, a, and b. It's been way too long to pull that stuff off the top of my head.) In any event, any natural number can be expressed as a unique product of primes. So we can determine whether a number n is prime by asking whether any prime established so far divides n. If not, and if we have thus far established a prime whose square is greater than n, then we know that n itself must be prime.
        </p>

        <div class="code-listing">
          <span class="listing-heading">square</span>
          <span class="listing-secondary-heading">number &#8614; square of the given number</span>
          <pre>var square = function (n) {
  return Math.pow(n, 2);
};</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">isPrime</span>
          <span class="listing-secondary-heading">prime number &#8614; true</span>
          <span class="listing-secondary-heading">non-prime number &#8614; false</span>
          <pre>var isPrime = function (n) {
  function loop(ps) {
    if (square(head(ps)) &gt; n) return true;
    if (isDivisible(n, head(ps))) return false;
    return loop(tail(ps));
  }

  return loop(primes);
};</pre>
        </div>

        <div class="code-listing">
          <span class="listing-heading">primes</span>
          <pre>var primes = consStream(2,
                        function () {
                          return filterStream(isPrime, integersStartingFrom(3));
                        });</pre>
        </div>
      </section>
    </section>



    <section>
      <a name="use"></a>

      <h2>
        That's interesting but are streams actually useful?
      </h2>

      <p>
        Let's consider two methods of finding the second prime between 10,000 and 100,000: an imperative method and a stream-processing method. The stream-processing method will use functions to express our computational procedure, allowing us to write code that is closer to the level of the problem and of our thinking. Such a style could be very inefficient for the computer to execute but the use of streams instead of lists, while not as efficient as an imperative method, will hold the inefficiency to a level that may be acceptable for a given application.
      </p>

      <h3>
        Imperative method
      </h3>

      <p>
        The following code produces the second prime between 10,000 and 100,000. We'll check primality by determining whether a number is its own smallest divisor greater than 1.
      </p>

      <div class="code-listing">
        <span class="listing-heading">findSmallestDivisorOfNotLessThan</span>
        <span class="listing-secondary-heading">number, smallest potential divisor &#8614; smallest divisor of the number not less than the given smallest potential divisor</span>
        <pre>var findSmallestDivisorOfNotLessThan = function (n, testDivisor) {
  if (square(testDivisor) &gt; n) return n;
  if (isDivisible(n, testDivisor)) return testDivisor;
  return findSmallestDivisorOfNotLessThan(n, testDivisor + 1);
};</pre>
      </div>

      <div class="code-listing">
        <span class="listing-heading">smallestDivisorOf</span>
        <span class="listing-secondary-heading">number &#8614; smallest divisor of the number greater than 1</span>
        <pre>var smallestDivisorOf = function (n) {
  return findSmallestDivisorOfNotLessThan(n, 2);
};</pre>
      </div>

      <div class="code-listing">
        <span class="listing-heading">isPrime2</span>
        <span class="listing-secondary-heading">prime number &#8614; true</span>
        <span class="listing-secondary-heading">non-prime number &#8614; false</span>
        <pre>var isPrime2 = function (n) {
  return n === smallestDivisorOf(n);
};</pre>
      </div>

      <div class="code-listing">
        <span class="listing-heading">nthPrimeInInterval</span>
        <span class="listing-secondary-heading">natural number (ordinal of prime in interval to find), interval min (inclusive), interval max (inclusive) &#8614; prime of given ordinal within the interval if such a prime exists, or a message that no such prime exists</span>
        <pre>var nthPrimeInInterval = function (n, min, max) {
  var i = min,
      prime,
      numberOfPrimesFound = 0;

  for (; i &lt;= max &amp;&amp; numberOfPrimesFound &lt; n; i++) {
    if (isPrime2(i)) {
      prime = i;
      numberOfPrimesFound += 1;
    }
  }

  if (numberOfPrimesFound &lt; n) {
    return ["Only found ", n, " primes in interval [", min, ", ", max, "]."].join("");
  }
  return prime;
};</pre>
      </div>

      <div class="example">
        <pre>nthPrimeInInterval(2, 10000, 100000);</pre>
        <span class="code return-value"><span class="return-value-prefix">yields:</span>10009</span>
      </div>

      <h4>
        Reflection
      </h4>

      <p>
        On one hand, the language gives us all the machinery we need. Additionally, nthPrimeInInterval executes quickly; performance improvements will have to come from better prime-checking algorithms. (This algorithm is O(sqrt(n)) but we could use an O(log(n)) algorithm.) If speed or power consumption were high priorities for a program, then something like this method would likely be the best choice.
      </p>

      <p>
        On the other hand, nthPrimeInInterval mixes enumeration, iteration, and filtering throughout the code. In math, the value of a variable doesn't change once set. In nthPrimeInInterval, however, the values of i, prime, and numberOfPrimesFound change as the program executes. In order to read and understand nthPrimeInInterval, we have to follow those values "through time". A program is easier for us to understand when variables are immutable.
      </p>

      <p>
        Additionally, language-syntax accounts for a much greater portion of this function than the code we've seen previously &mdash; nthPrimeInInterval is closer to the level of the computer and farther from the level of the problem and our thinking.
      </p>

      <h3>
        Stream-processing method
      </h3>

      <p>
        We can make the same calculation, finding the second prime between 10,000 and 100,000, using the stream-processing tools we've built:
      </p>

      <p>
        We'll use <span class="new-code-ref">enumerateInterval</span> to create a finite stream of numbers.
      </p>

      <div class="code-listing">
        <span class="listing-heading">enumerateInterval</span>
        <span class="listing-secondary-heading">min, max, step (defaults to 1) &#8614; stream of a range from lower bound to upper bound, by the step</span>
        <pre>var enumerateInterval = function (min, max, step) {
  if(_.isUndefined(step)) step = 1;

  if (min &gt; max) return theEmptyStream;
  return consStream(min,
                    function () {
                      return enumerateInterval(min + step, max, step)
                    });
};</pre>
      </div>

      <div class="example">
        <pre>nthStream(1,
          filterStream(isPrime,
                       enumerateInterval(10000, 100000)));</pre>

        <span class="code return-value"><span class="return-value-prefix">yields:</span>10009</span>
      </div>

      <h4>
        Reflection
      </h4>

      <p>
        Here we have separated and abstracted away enumeration, filtering, and iteration. We are telling the computer what we want to accomplish instead of the steps to take that we know will accomplish our goal &mdash; this solution is closer to the level of the problem and our thinking.
      </p>

      <p>
        What's the tradeoff? Performance. The stream method executes more slowly and thus uses more power. Whether those differences are important will depend on the requirements for the program.
      </p>

      <p>
        If we build our streams with a simple <span class="code">delay</span>, then every time we ask for a prime, we give candidates to <span class="code">isPrime</span> and for each candidate, <span class="code">isPrime</span> begins building <span class="code">primes</span> anew. There is a <em>lot</em> of repeated calculation. When we use <span class="code">memoProc</span>, though, each prime in <span class="code">primes</span> is only calculated once. Still, there is overhead for additional function calls, compared to the imperative method, and our memoized stream method runs more slowly than the imperative method:
      </p>

      <p>
        <strong>Average execution time (in milliseconds) of a single run, over 100,000 runs in the Chrome JavaScript console on my computer</strong>
      </p>

      <p>
        Imperative method: 0.00817 ms
      </p>

      <p>
        Stream method: 0.28796 ms
      </p>

      <p>
        The imperative method is about 30X faster than the stream method in this test. When looking for the 500th prime, the imperative method ran about 100X faster. The difference may or may not be important for a given application.
      </p>

      <h4>
        Versus lists
      </h4>

      <p>
        Consider what would happen if we used lists, instead of streams, in the above procedure. The code would still separate enumeration, filtering, and iteration and would not reassign variables over time. The price would be even greater inefficiency than with non-memoized streams, though. The entire interval from 10,000 to 100,000 would be generated and filtered for primality. After all of that computation, we would take only the second prime.
      </p>
    </section>



    <section>
      <a name="application"></a>

      <h2>
        Application: integrator
      </h2>

      <p>
       We have almost built up enough machinery to make an integrator. Let x = (x_i) be a stream of values such that x_i is the value of a function / signal at time t_i and where the distance between times is a constant &Delta;t. We can make an integrator that takes as input an initial value, C, and x and &Delta;t as above, and produces as output a stream of sums S = (S_j) such that S_j = C + &sum; x_i * &Delta;t, from i = 1 to j. That is, going farther into the sequence S is equivalent to integrating from the initial time to later and later times.
      </p>

      <p>
        Let <span class="new-code-ref">mapStream</span> map a stream to a new stream, via elementwise application of a given function.
      </p>

      <div class="code-listing">
        <span class="listing-heading">mapStream</span>
        <span class="listing-secondary-heading">function f, stream &#8614; new stream such that new_i = f(old_i)</span>
        <pre>var mapStream = function (f, stream) {
  if (isEmptyStream(stream)) return theEmptyStream;
  return consStream(f(head(stream)),
                    function () {
                      return mapStream(f, tail(stream));
                    });
};</pre>
      </div>


      <p>
        Let <span class="new-code-ref">scaleStream</span> produce an elementwise-scaled version of a stream.
      </p>

      <div class="code-listing">
        <span class="listing-heading">scaleStream</span>
        <span class="listing-secondary-heading">scalar, stream &#8614; new stream such that new_i = scalar * old_i</span>
        <pre>var scaleStream = function (scalar, stream) {
  return mapStream(function (x) { return scalar * x; }, stream);
};</pre>
      </div>

      <p>
        Let <span class="new-code-ref">integral</span> approximate the Riemann integral of a function (or signal) with the Riemann sum, using right endpoints.
      </p>

      <div class="code-listing">
        <span class="listing-heading">integral</span>
        <span class="listing-secondary-heading">integrand, initial value, &Delta;t &#8614; stream of approximate integrals, where going farther down the stream yields integrals from the initial time to later and later times</span>
        <pre>var integral = function (integrand, initialValue, deltaT) {
  function int() {
    return consStream(initialValue,
                      function () {
                        return addStreams(scaleStream(deltaT, integrand),
                                          int());
                      });
  }

  return int();
};</pre>
      </div>

      <p>
        Let's test <span class="code">integral</span> by integrating f(x) = e^x over [0, a], a &gt; 0. We can parametrize x as x(t) = t; t &isin; [0, a]. Then let &Delta;t = 0.01 and let the intitial value be 0.
      </p>

      <div class="example">
        <pre>var expStream = mapStream(function (x) { return Math.exp(x); },
                          enumerateInterval(0, 1.001, 0.01));

var integralOfExp = integral(expStream, 0, 0.01);</pre>
        <pre>nthStream(0, integralOfExp);</pre>
        <span class="code return-value"><span class="return-value-prefix">yields:</span>0, and we know (&int; e^x dx from x = 0 to 0) = 0</span>
        <pre>nthStream(100, integralOfExp);</pre>
        <span class="code return-value"><span class="return-value-prefix">yields:</span>1.710, and we know (&int; e^x dx from x = 0 to 1) = e^1 - e^0 &cong; 1.718 (% error = 0.500%)</span>
      </div>
    </section>



    <section>
      <hr />
    </section>



    <section>
      <p>
        I used the following code to time the execution of the procedures above:
      </p>
      <div class="code-listing">
        <pre>var benchmarkRun = function (f) {
  var start,
      end,
      timeMessage,
      fResult;

  start = Date.now();
  f();
  end = Date.now();

  return end - start;
};

var add = function (x, y) {
  return x + y;
};

var benchmark = function (numberOfRuns, f) {
  var results = _.map(_.range(numberOfRuns),
                      function () { return benchmarkRun(f); }),
      averageTime = _.reduce(results, add, 0) / _.size(results),
      fResult = f();

  return ["result: ", fResult, "\n", "average time: ", averageTime].join("");
};</pre>
      </div>

      <div class="example">
        <pre>benchmark(100000,
          function () {
            return nthPrimeInInterval(2, 10000, 100000);
          });</pre>
      </div>

      <div class="example">
        <pre>benchmark(100000,
          function () {
            return nthStream(1,
                             filterStream(isPrime,
                                          enumerateInterval(10000, 100000)));
          });</pre>
      </div>
    </section>
  </div>

  <script src="bower_components/underscore/underscore.js"></script>
  <script src="bower_components/underscore-contrib/dist/underscore-contrib.js"></script>
  <script src="streams.js"></script>
</body>
</html>
